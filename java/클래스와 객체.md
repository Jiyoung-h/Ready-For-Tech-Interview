#  클래스와 객체

## 객체 지향 언어
>객체 지향 언어는 상속, 다형성, 객체, 캡슐화 등 **소프트웨어의 재사용**을 위한 여러가지 장치를 내장하고 있어 소프트웨어의 생산성이 향상된다.


|절차 지향 프로그래밍|  객체 지향 프로그래밍|
|--|--|
| 명령들의 순서 또는 흐름에 중점 | 일과 관련된 많은 물체들을 객체로 표현, 상호 작용으로 묘사 |
|흐름도상의 동작들을 함수로 작성하고 실행 | 객체, 메소드, 필드를 설계 및 구현 |

### 객체 지향 언어의 특성
1. 캡슐화 : 객체를 캡슐로 싸서 그 내부를 보호하고 볼 수 없게 하는 것
	- 객체 : 클래스 내부에 메소드와 필드로 구성
	- 몇몇 메소드와 필드만 객체 외부와의 인터페이스를 위해 노출
	- 목적 : 보안, 보호, 외부 접근 제한 → 정보 은닉화
2. 상속 : 슈퍼 클래스의 속성을 서브 클래스가 물려받는 개념
	- 코드의 중복 작성을 방지 → 코드의 재사용
3. 다형성 : 같은 이름의 메소드 호출에 대해 객체에 따라 다른 동작을 수행 → 오버로딩, 오버라이딩

### 클래스와 객체
- **클래스** : 객체를 생성하기 위한 틀
- **객체** : 틀로 찍어낸 실체 → 객체는 클래스의 **인스턴스**
- 변수 선언과 객체 생성
```
Person a;			// 변수 선언
a = new Person();	// 객체 생성, 생성자
```
- 객체 배열 생성
```
 Person[] a;			// 레퍼런스 선언 
 a = new Person[10];	// 레퍼런스 배열 선언 → 객체는 아직 존재X
 a[0] = new Person();	// 객체 생성
```

## 메소드 

### 메소드 형식
- 접근 지정자
	- public : 클래스 내부/외부 모두 호출 가능
	- private : 클래스 내부 멤버들만 호출 가능
	- protected : 클래스 내부, 상속받은 서브 클래스만 호출 가능
		- 상속받은 클래스들이 오버라이딩을 해야할 때
	- default : 동일 패키지 내의 모든 클래스가 호출 가능
		- 인터페이스에서 구현할 때
- 리턴 타입
- 메소드 이름과 인자

### 인자 전달 (call-by-value)
- 기본 타입 : 인자의 값을 복사 → 원본 변수와 무관
- 객체 레퍼런스 : 레퍼런스 값을 복사
- 배열 : 레퍼런스 값을 복사 → 객체/배열이 통째로 복사되지 않음, 참조

### 메소드 오버로딩 
> 이름이 같지만 인자의 타입이나 개수가 서로 다른 여러개의 메소드를 중복 작성
### this
> 현재 실행되는 메소드가 속한 객체에 대한 레퍼런스, 컴파일러에 의해 자동으로 생성된다.
### 생성자
> 객체가 생성될 때 초기화를 위해 자동으로 호출되는 메소드
- 생성자의 이름은 클래스의 이름과 동일하다.
- ``new``를 통해 객체를 생성할 때만 호출된다.
- 오버로딩이 가능하다.
- 리턴 타입을 지정할 수 없다.
- **기본생성자** : 생성자가 선언되어 있지 않으면 컴파일러가 기본 생성자를 자동으로 생성 → 하나라도 존재하는 클래스에는 자동으로 생성되지 않는다.
- **this()** : 클래스 내에서 한 생성자에서 다른 생성자를 호출할 때 사용
	- 생성자 코드에서만 사용할 수 있다.
	- 동일한 클래스 내에서 다른 생성자를 호출할 떄 사용한다.
	- 반드시 생성자의 첫 문장에서 사용되어야 한다.
```
public Book(String title, String author){
	this.title = title;
	this.author = author;
}
public Book(){
	this(null, null); 		// this() 사용하여 다른 생성자 호출
	System.out.println("생성");	// this()는 반드시 첫 문장
}
```
### 객체의 소멸
> 객체 소멸이란 ``new``에 의해 생성된 객체 메모리를 자바 가상 기계(JVM)에 돌려주어 가용 메모리에 포함시키는 것이다.
- C++에서는 ``new`` 로 할당받은 객체가 더이상 필요 없을 때 ``delete`` 연산자를 사용하여 소멸자를 호출한다.
- 자바에서는 **객체나 배열을 가리키는 레퍼런스가 하나도 없어** 사용하지 않게 된 객체 메모리는 **가비지**가 되며, 자바 가상 기계의 **가비지 컬렉터**에 의해 적절한 시점에 자동으로 수집되어 가용 메모리에 리턴된다.
### 가바지 컬렉션
- 자바 가상 기계는 가용 공간이 일정 크기 이하로 줄어들게 되면 자동으로 가비지를 회수하여 가용 메모리 공간을 늘린다.
- 가비지 컬렉터 : 가비지 컬렉션을 수행하는 주체
- 가비지 컬렉션 스레드 : 가비지 컬렉터 역할을 수행하는 스레드
- 가용 메모리가 거의 없어지는 상황은 잘 일어나지 않기 때문에 언제 가비지 컬렉션이 일어나는지 알기 어렵다.
	- 가용 메모리가 부족해지는 경우 자바 프로그램은 실행을 멈추고 기비지 컬렉션이 끝나기를 기다리게 되어 프로그램이 중단된 것처럼 보인다. → 실시간 처리 응용에는 부적합
- 강제 수행 : ``System.gc();`` → 가비지 컬렉션이 즉시 작동되는 것은 아니고 강력한 제안을 하는 것에 불과하다.

### 클래스 접근 지정자
1. public
2. default : 같은 클래스 내에 있는 클래스들만 접근이 허용
### 멤버 접근 지정자
1. public
2. private
3. protected : 같은 패키지 내의 모든 클래스, 상속받은 자식
4. default : 같은 패키지 내의 모든 클래스

### static 멤버
|non-static 멤버(인스턴스 멤버)|  static 멤버(클래스 멤버)|
|--|--|
| 객체마다 별도 존재 | 클래스당 하나 생성 |
|객체와 같이 생성/소멸|프로그램을 시작할 때 이미 생성, 프로그램이 종료될 때 소멸|
|공유X|동일한 클래스의 모든 객체들이 공유|
|(객체.멤버)|(객체.멤버) 또는 (클래스.멤버)로 접근|

- 활용 : 전역 변수나 전역 함수를 만들 때 활용
	- EX) java.lang.Math : 객체를 생성하지 않고 바로 호출할 수 있는 상수와 메소드를 제공
- 제약 조건 
	- static 메소드는 오직 static 멤버만 접근할 수 있다.
	- static 메소드는 this 키워드를 사용할 수 없다.

### final 
- final 클래스 : ``final``이 클래스 이름 앞에 사용되면 클래스를 상속받을 수 없음
- final 메소드 : 더 이상 오버라이딩 할 수 없음
- final 필드 : 상수 정의
 
