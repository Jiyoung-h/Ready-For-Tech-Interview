# 상속
> 부모 클래스(슈퍼 클래스)에 정의된 필드와 메소드를 자식 클래스(서브 클래스)가 물려받는것

### 상속의 장점
1. 클래스 사이의 멤버 중복 선언 불필요
2. 필드와 메소드 **재사용**으로 클래스 간결화
3. 클래스 간 **계층적 분류** 및 관리

- 자바에서는 ``extends`` 키워드를 사용한다.

### 자바 상속의 특징
1. 다중 상속을 지원하지 않는다.
2. 상속의 횟수에 제한을 두지 않는다.
3. 계층 구조의 최상위에 있는 클래스는 ``java.lang.Object``클래스이다.

### 상속과 생성자
- 서브 클래스의 인스턴스가 생성될 때 서브 클래스의 생성자와 슈퍼 클래스의 생성자가 모두 실행된다.
- 슈퍼 클래스의 생성자가 먼저 실행된 후 서브 클래스의 생성자가 실행된다.
	- 서브 클래스 생성자 호출 → 슈퍼 클래스 생성자 호출 → 슈퍼 클래스 생성자 실행 → 서브 클래스 생성자 실행

- 서브 클래스의 생성자가 기본 생성자이든 매개 변수를 가진 생성자에든 **슈퍼 클래스의 생성자로 기본 생성자**가 선택된다.
	- 자바 컴파일러에 의해 이루어진다.
	- 슈퍼 클래스에 기본 생성자가 없는 경우 컴파일러에 의해 오류 메세지 발생
- ``super()`` 을 이용하여 명시적으로 슈퍼 클래스의 생성자 호출
	- 명시적으로 선택하지 않으면 자동으로 기본 생성자 호출
	- 괄호 안에 매개 변수 리스트를 적는다.
	- super()의 사용은 반드시 생성자 코드의 첫 라인
```
public B(int x){
	super(x);	// 슈퍼 클래스 A의 매개변수 생성자 실행
}
public A(int x){
				// 매개변수 생성자 실행
}
```

## 객체의 타입 변환
> 캐스팅이란 개발자가 프로그램 코드로 행하는 강제 타입 변환
### 업캐스팅
> 서브 클래스 객체가 슈퍼 클래스 타입으로 변환되는 것
```
Person p;
Student s = new Student();
p = s; 	// 업캐스팅 
```
- 레퍼런스 p를 이용하면 Person의 멤버만 접근 가능
- 레퍼런스 s를 이용하면 Student, Person의 멤버 모두 접근 가능
- ``p = (Person) s;`` 와 같이 명시하지 않아도 된다.

### 다운캐스팅
> 업캐스팅된 서브 클래스 객체를 다시 원래대로 되돌리는 것
- 명시적으로 타입을 지정해야 한다.
	- ``Student s = (Student) p;``

### ``instanceof`` 연산자와 객체 구별
```
void f(Person p){
	// p가 가리키는 객체는 Person 타입일 수 도 있고
	// Student, Player, Teacher, ... 타입일 수 도 있다.
}
```
- 실제 객체가 어떤 클래스 타입인지 구분하기 위해 ``instanceof`` 연산자 사용
	- ex) ``if(jee instanceof Person)`` jee는 Person 타입인지 판별 
	- 결과 값은 ``boolean`` 타입
	- 객체에 대한 레퍼런스에만 사용 가능

### 메소드 오버라이딩
> 슈퍼 클래스의 메소드를 동일한 이름으로 서브 클래스에서 재작성
- 같은 이름, 같은 리턴 타입, 같은 매개 변수 리스트를 갖는다.
- 슈퍼 클래스의 메소드를 무시하고 서브 클래스에서 오버라이딩된 메소드가 무조건 실행되도록 동적 바인딩 된다.
```
DObject p = new Line();
p.draw();	// Line 클래스의 draw로 동적 바인딩
```
### @Override
> 컴파일러에게 다음 라인이 오버라이딩하는 메소드임을 알려주어 원형을 체크하도록 지시하여 컴파일 오류를 발견한다.

### 메소드 오버라이딩 조건
1. 같은 이름, 같은 리턴 타입, 같은 매개 변수 리스트를 갖는 메소드
2. 슈퍼 클래스 메소드의 접근 지정자보다 접근의 범위가 좁아질 수 없다.
	- ex) 슈퍼 클래스의 메소드가 ``protected`` 라면 서브 클래스의 메소드는 ``protected/public``
3. ``static``, ``private``, ``final``로 선언된 메소드는 오버라이딩 불가능

### 동적 바인딩
> 실행한 메소드를 컴파일시가 아니라 **실행시**에 결정하는 것을 말한다. 오버라이딩된 메소드가 항상 우선적으로 호출된다.
### 오버라이딩과 ``super`` 키워드
- ``super`` 키워드를 이용하면 슈퍼 클래스의 멤버에 접근할 수 있다.
- 자바에서 자동으로 지원되는 것으로 **슈퍼 클래스에 대한 레퍼런스**이다.


|오버로딩|오버라이딩  |
|:--:|:--:|
| 같은 클래스나 상속 관계에서 동일한 이름의 메소드 중복 작성 | 서브 클래스에서 슈퍼 클래스에 있는 메소드와 동일한 이름의 메소드 재작성 |
|이름은 동일하고, 인자의 개수나 타입이 달라야 함|모두 동일해야 함|
|정적 바인딩|동적 바인딩|

## 추상 메소드
> 선언은 되어 있으나 코드가 구현되어 있지 않은 메소드
```
public abstract String getName();
```
- 구현부가 있으면 추상 메소드가 될 수 없다.
### 추상 클래스의 종류
1. 추상 메소드를 포함하는 클래스 → 반드시 ``abstract``로 선언
2. 추상 메소드가 하나도 없지만 ``abstract``로 선언한 클래스

- 추상 클래스는 인스턴스를 생성할 수 없다.
- 추상 클래스의 레퍼런스 변수를 선언하는 것은 오류가 아니다.
```
DObject obj;			// 오류 X
obj = new DObject();	// 오류 O
```

### 추상 클래스의 상속
- 추상 클래스를 상속 받으면 상속 받은 서브 클래스도 추상 클래스
- ``abstract``를 붙여 명시하지 않으면 컴파일 오류
- 서브 클래스가 추상 클래스가 되지 않기 위해서는 추상 메소드를 **모두 오버라이딩하여 구현**하여야 한다.
	- 응용프로그램의 설계와 구현을 분리
	- 추상 클래스로 기본 방향을 잡아놓고 서브 클래스에서 구현

## 인터페이스
### 특징
1. 멤버는 추상 메소드와 상수만으로 구성
	- ``abstract`` 키워드 생략 가능
2. 모든 메소드는 ``public`` → 생략 가능
3. 상수도 ``public static final`` 생략 가능
4. 인터페이스의 객체를 생성할 수 없다.
5. 다른 인터페이스에 상속될 수 있다.
	- 다중 상속 지원
	- ``interface MusicPhone extends MobilePhone, MP3 {``
6. 인터페이스도 레퍼런스 변수의 타입으로 사용 가능

### 인터페이스 구현
- ``implements`` 키워드를 사용하여 클래스 작성
- 모든 추상 메소드를 구현하지 않으면 컴파일 오류
- 다중 상속 받은 인터페이스의 모든 메소드를 구현해야 한다.
- 상속과 동시에 인터페이스를 구현하는 것도 가능하지만 관계가 복잡해지므로 지양

|추상 클래스| 인터페이스 |
|--|--|
|일반 메소드 포함  | 모든 메소드가 추상 메소드 |
|상수, 변수 필드|상수 필드|
|모든 서브 클래스에 공통된 메소드가 있는 경우에 추상 클래스가 적합|다중 상속 지원|
