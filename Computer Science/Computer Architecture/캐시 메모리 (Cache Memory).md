# 캐시 메모리 (Cache Memory)
: 속도가 빠른 장치와 느린 장치 사이의 속도 차이에 따른 병목 현상을 줄이기 위한 메모리
``병목(bottleneck) 현상은 전체 시스템의 성능이나 용량이 하나의 구성 요소로 인해 제한을 받는 현상을 말한다.``

- CPU가 주기억장치에 저장된 데이터를 읽어올 때, 자주 사용하는 데이터를 캐시 메모리에 저장한 뒤, 다음에 이용할 때 캐시 메모리에서 읽어오면서 속도를 향상
- 장점 : 속도 향상
- 단점 : 용량이 적고 비용이 비싸다

- CPU에는 캐시 메모리가 2~3개 정도 사용 된다. 
- 속도와 크기에 따라 L1, L2, L3 로 구분
- 일반적으로 L1 캐시부터 먼저 사용, 여기서 찾지 못하면 L2 접근

## 캐시 메모리 작동 원리
### 참조 지역성의 원리
	- **시간 지역성** : 한번 참조된 데이터는 잠시후 또 참조될 가능성이 높음
	(ex) for , while 과 같은 반복문에 사용하는 조건 변수
	- **공간 지역성** : 참조된 데이터 근처에 있는 데이터가 잠시후 사용될 가능성이 높음
	(ex) A[0], A[1], A[2], ...
	
CPU가 요청한 데이터가 캐시에 있으면 **Cache Hit**
없어서 DRAM에서 가져오면 **Cache Miss**

### Cache Miss의 경우 3가지
1. **Cold Miss** : 해당 메모리 주소를 처음 불러서 발생
2. **Conflict Miss** : 캐시 메모리에 A, B를 저장해야 하는데 A, B가 같은 캐시 메모리 주소에 할당되어 있어서 발생 (주소 할당 문제)
3. **Capacity Miss** : 캐시 메모리의 공간이 부족해서 발생

*캐시 크기를 키워서 해결하려면 캐시 접근속도가 느려지고 파워를 많이 소모하는 단점이 생긴다.*

## 구조 및 작동 방식
- Direct Mapped Cache : 가장 기본적인 구조
	- DRAM의 여러 주소가 Cache의 한 주소로 대응되는 다대일 방식 -> Conflict Miss 발생
	- 간단하고 빠르다
- Fully Associative Cache : 비어있는 캐시 메모리에 마음대로 주소를 저장
	- 간단하지만 찾기 어렵다
	- CAM이라는 특수한 메모리 구조를 사용해야하므로 매우 비싸다
- Set Associative Cache : Direct + Fully
	- 특정 행을 지정하고 그 행 안의 비어있는 열에 마음대로 저장
	- Direct 보다 저장이 빠르고 Fully보다 검색이 빠른 중간형
