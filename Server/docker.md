## Docker hub
1. local 에서 dockerfile을 빌드하여 docker image를 생성한다.
2. 만든 doker image를 dockerhub에 업로드한다. (push)
3. GCP instance 에서 dokerhub에 있는 docker image를 다운로드한다. (pull)
4. docker image를 run 하면 컨테이너가 되어 애플리케이션이 실행된다.

# Docker
> 컨테이너 : 애플리케이션을 환경에 구애 받지 않고 실행하는 기술, 어느 환경이든 상관 없이, 복잡한 설치 과정 없이 실행

### 눈송이 서버들 (Snowflake Servers)
- 각 서버마다 운영 기록이 다르기 때문에 처음 들어가는 서버에서는 문제를 해결하기 쉽지 않다.
- 똑같은 일을 하는 서버라도 서로 모양이 다른 서버들이 존재하는 상황을 ``눈송이 서버``라고 한다. → 특정 서버에서만 장애가 발생할 수 있음
- 문제점 : 장애 원인을 찾기 위해 서버들간의 차이점을 찾아내야 한다.

### 개선 : 서버 운영 기록 저장
- 사내 문서 도구에 기록
- tool : tmux-xpanes (여러 서버에서 동시 접속하여 한꺼번에 명령어를 실행하는 도구) 
<br> → 특정 서버 하나만 문제를 일으키는 경우가 발생한다.
- 서버의 운영 기록을 코드화 : Vagrant, Chef, Puppet, Ansible 등
	- 도커 파일 (Dockerfile) → 도커 이미지 생성
	- 도커 파일이 **서버 운영 기록** 이라면, 도커 이미지는 운영 기록을 **실행 시점** 이라고 할 수 있다.
		- 도커 파일 = 서버 운영 기록 코드화
		- 도커 이미지 = 도커 파일 + 실행 시점

<br> (예) 
- Ansible 의 플레이북으로 1년 차이를 두고 서버 A와 B를 실행하면 설치된 시점은 1년의 차이가 발생한다.
- 도커의 도커 이미지로 1년 차이를 두고 서버 A와 B에 컨테이너를 배포한다고 해도, 두 컨테이너 모두 설치된 시점이 같기 때문에 차이가 발생하지 않는다.

## 테스트 주도 개발의 관점에서의 도커 파일
### TDD
테스트 작성 → 테스트 실패 → 코드 작성/수정 → 테스트 성공 → 코드 리팩토링 → 테스트 작성 → ...

### 도커 파일
도커 파일 생성 → 도커 이미지 생성 실패 → 도커 파일 작성/수정 → 도커 이미지 생성 성공 → 리팩토링(효율화) → 도커 파일 생성 → ...

> 서버를 만들 때 미리 실패해보는 일 !  지금 미리 겪은 실패는 약간의 기다림과 귀찮음 뿐이지만, 지금 겪지 않은 실패는 훗날 서비스 장애로 이어진다.

## 도커 이미지

- 서버에 설치하는 패키지가 보안 문제를 겪어서 하루 사이에 패치되었다면 컨테이너 내부에 존재하는 서버는 달라질 수도 있다. → 서버는 바뀌어야 할 부분도 존재한다.
- 도커 파일에 실행 시점을 더한 것이 도커 이미지라면, 도커 이미지에 실행 시점에 수정되어야 할 정보들을 더한 것이 도커 컨테이너이다.
	- 도커 파일 = 서버 운영 기록
	- 도커 이미지 = 도커 파일 + 실행 시점
	- 도커 컨테이너 = 도커 이미지 + 환경 변수
-  도커 덕분에 서버를 설치하고 운영 기록을 별도로 관리하는 고단함 없이, 잘 만들어진 서버를 사용할 수 있다. (Dockerhub)
- 한 도커 이미지로 생성할 수 있는 컨테이너 갯수에 제한이 없다.

### 서버 코드화의 장점
1. 서버 제작 과정에 **견고함과 유연성**
2. 다른 사람이 만든 서버를 가져다 쓸 수 있음
3. 여러 대에 배포할 수 있는 **확장성**

